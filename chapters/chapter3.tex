\chapter{概述}
在本节中，我们正式定义我们的问题，并阐述这些挑战及相应的解决方案。

\section{A. 问题描述}
令 $M$ 表示一个由 $F$ 个文件组成的恶意软件程序，其中第 $i$ 个文件 ($1 ≤ i ≤ F$) 包含 $G$ 个函数，记作 \{$f_{1}^{i}$, $f_{2}^{i}$, ..., $f_{G}^{i}$\}。对于由语言模型（LLM）应用的给定转换策略 $s$，我们的目标是生成一个恶意软件变种 $M_{s}$，其中第 i 个文件包含使用策略 s 生成的修改后函数 \{$\hat{f_{1}^{i}}$, $\hat{f_{2}^{i}}$, ..., $\hat{f_{j}^{i}}$\}，同时保留未修改的函数 \{$f_{j+1}^{i}$, ..., $f_{G}^{i}$\}。该过程首先涉及从第 $i$ 个文件中提取第 $j$ 个函数 $f_{j}^{i}$，并构建一个提示符 $p_{s}||f_{j}^{i}$，该提示符包含转换策略 $s$、提取的函数 $f_{j}^{i}$ 以及相关上下文信息（如全局变量和头文件）。然后我们得到转换后的函数 $\hat{f_{j}^{i}} = LLM(p_{s}||f_{j}^{i})$ 。随后，将修改后的函数 $f_{j}^{i}$ 合并回源代码文件 $i$，生成一个修改后的文件，其中函数 \{$\hat{f_{2}^{i}}$, ..., $\hat{f_{j}^{i}}$\} 被修改，而其余函数 \{$f_{j+1}^{i}$, ..., $f_{G}^{i}$\} 保持不变。最后，重构的文件被编译以生成变种恶意软件 $\hat{M_{s}}$。

\section{B. 挑战与解决方案概述}
我们现在讨论指导我们设计 LLMalMorph 的主要挑战和解决方法。

\subsection{(C1) 编辑恶意软件源码中的上下文与结构挑战}
由于在训练语料库中包含了大量开源代码库 [8]–[10], [12]，LLM 研究的最新进展极大地改进了跨多种语言的代码生成。除了生成代码，使用 LLM 进行代码编辑和重构也正受到关注 [13], [14]。一个关键挑战是上下文限制：提供完整的源代码和转换指令通常会超出模型的输入能力并阻碍指令遵循，特别是对于较小的模型。此外，恶意软件代码中的功能通常分布在多个文件中，这进一步使编辑过程复杂化。在处理 C 和 C++ 时，这个问题变得更加明显，因为它们经常导致产生无法编译或无法按预期执行的错误代码 [33]。这与恶意软件高度相关，因为这些程序经常利用系统调用 API 进行注册表修改、执行网络系统调用、进程修改或实施反规避技术。在基于 Windows 的恶意软件中，这些操作严重依赖于 Windows API 调用结合 C/C++ 或 C\# 功能。因此，鉴于原生系统 API 的复杂性和上下文限制，使用 LLM 编辑大规模的恶意软件源代码仍然是一个重大挑战。

\subsection{(A1) 在功能级别生成恶意软件变体的框架}
为了应对挑战 C1，LLMalMorph 通过几个关键阶段运作。它首先遍历恶意软件源代码文件的抽象语法树 (AST)，以系统地提取函数主体、头文件信息和全局变量声明。随后，提取出的组件作为开源 LLM 的输入，其中精心设计的提示指导函数修改过程。最后，修改后的组件被重新整合回源代码，生成原始恶意软件的功能性变体。这种方法确保了恶意软件组件的精确提取和修改，同时在整个转换过程中保持其结构完整性，且不会使 LLM 负担过重。

\subsection{(C2) 使用基于LLM的函数修改时恶意软件代码库一致性保持的挑战}
恶意软件项目通常跨越多个文件，其中修改一个部分通常需要跨其他相关文件进行协调更改。鉴于当前LLM的能力，在保持多文件代码库一致性的同时编辑源代码，在没有人工监督的情况下可能过于容易出错，因为LLM在多文件修改、依赖关系解析、项目级配置以及跨大型代码库的编辑方面存在困难 [34], [35]。例如，使用指定转换重构单个函数可能需要在关联的头文件中进行更新、在整个代码库中重构和重命名其用法、或添加新头文件、链接静态库、修改编译器指令、或更改整个项目的语言配置以适应LLM生成的代码。虽然添加头文件或在单个文件内重命名等简单任务可以实现自动化，但更复杂的多步骤修改在很大程度上取决于LLM生成更改的性质和特定恶意软件项目的结构，这使得一刀切的解决方案不可行。尽管像Copilot3这样底层使用LLM的技术改进了多文件处理，但上下文限制仍然是阻碍将开源LLM接入整个代码库的关键障碍，该代码库能够可靠地重构互连的代码库，因此在泛化到各种恶意软件项目方面存在不足。代码生成的LLM幻觉问题 [36], [37] 加剧了这些限制，导致新的复杂问题，如在代码生成过程中使用虚构的函数或误用现有API。因此，调试LLM通常涉及试错，且其当前能力不足以处理超出简单语法和逻辑问题的复杂错误修复。

\subsection{(A2) 融入人在回路流程}
为了解决 C2，我们选择了一种部分自动化的解决方案来生成恶意软件功能变体。如 A1 所述，我们以自动化方式生成具有功能转换的源代码。然而，为了保持一致性和正确性，我们采用人在回路流程来处理跨多文件恶意软件项目的复杂调试和配置更改。