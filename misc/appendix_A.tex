\chapter{不同子程序的细节}
\section{A. 关于基于LLM的代码生成的细节}
如算法1所述，我们将提示连同函数和相关信息传递给LLM，以生成修改后的代码。LLM处理该提示并产生响应，我们解析该响应以提取生成的代码。在生成代码时，我们遇到了两个关键挑战性案例：

• LLM偶尔未能以期望的格式生成代码。
• LLM有时会描述给定函数的机制，而不是生成任何代码。

在第二种情况中，模型要么提供了对输入函数的详细解释，要么基于提供的上下文将该函数识别为潜在恶意并生成了对给定代码的分析。为了解决这些挑战，我们实现了一个重试机制。当任一情况发生时，我们使用不同的随机种子最多提示LLM五次。如果LLM仍然未能生成可用的代码，我们则回退到原始函数并继续进行解析代码的下一步。由于我们提示模型以特定格式生成代码，因此我们可以从生成的响应中解析代码，保存生成的代码，并记录有用的信息以供我们的指标计算，例如生成的代码行数、生成代码所需的时间、生成代码的路径等。我们在算法~\ref{alg:Malware Variant Generation}后续的合并阶段利用了这些信息。

\section{B. 关于“merger”子程序的细节}
该子程序仔细追踪哪些函数需要更新、哪些保持不变，在整个过程中保持两者之间的明确区分。它保留源文件中的原始头声明和全局变量，以保持项目范围内的一致性。这种方法防止了文件内部或延伸到其他文件中可能出现的依赖关系的潜在破坏。此外，我们指示LLM避免声明任何全局变量，并仅依靠创建和使用函数内部的局部变量。这确保了模块化并防止了意外的副作用。在转换后的函数被拆分为子函数的情况下，“merger”子程序有条不紊地定义它们的原型，将这些子函数放置在文件的开头，并整合了修改后的原始函数，该函数现在调用这些子函数。
通过遵循这些准则，“merger”子程序确保了转换后函数的集成是健壮和结构化的，并最大程度地降低了在代码库中引入不一致性的风险。

